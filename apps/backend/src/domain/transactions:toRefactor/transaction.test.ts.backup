// /* eslint-disable @typescript-eslint/no-unsafe-argument */
// import { UUID } from '@ledgerly/shared/types';
// import { describe, expect, it } from 'vitest';

// import { Transaction } from './transaction.entity.js';

// describe('Transaction', () => {
//   const userId = 'user-123' as UUID;

//   describe('create', () => {
//     it('should create a new transaction with required data', () => {
//       const description = 'Test transaction';
//       const transaction = Transaction.create({ description, userId });

//       expect(transaction.id).toBeNull();
//       expect(transaction.userId).toBe(userId);
//       expect(transaction.description).toBe(description);
//       expect(transaction.isNew).toBe(true);
//       expect(transaction.canBeModified).toBe(true);
//       expect(transaction.entriesCount).toBe(0);
//       expect(transaction.entries).toEqual([]);
//     });

//     it('should trim description', () => {
//       const transaction = Transaction.create({
//         description: '  Test transaction  ',
//         userId,
//       });

//       expect(transaction.description).toBe('Test transaction');
//     });

//     it('should throw error for missing user ID', () => {
//       expect(() =>
//         Transaction.create({ description: 'Test', userId: '' as UUID }),
//       ).toThrow('User ID is required');
//     });

//     it('should throw error for empty description', () => {
//       expect(() => Transaction.create({ description: '', userId })).toThrow(
//         'Description is required',
//       );

//       expect(() => Transaction.create({ description: '   ', userId })).toThrow(
//         'Description is required',
//       );
//     });

//     it('should throw error for description too long', () => {
//       const longDescription = 'a'.repeat(501);

//       expect(() =>
//         Transaction.create({ description: longDescription, userId }),
//       ).toThrow('Description cannot exceed 500 characters');
//     });

//     it('should allow exactly 500 characters', () => {
//       const maxDescription = 'a'.repeat(500);
//       const transaction = Transaction.create({
//         description: maxDescription,
//         userId,
//       });

//       expect(transaction.description).toBe(maxDescription);
//     });
//   });

//   describe('restore', () => {
//     it('should restore transaction from data', () => {
//       const data = {
//         createdAt: new Date('2023-01-01'),
//         description: 'Restored transaction',
//         id: 'transaction-456' as UUID,
//         updatedAt: new Date('2023-01-02'),
//         userId,
//       };

//       const transaction = Transaction.restore(data);

//       expect(transaction.id).toBe(data.id);
//       expect(transaction.userId).toBe(data.userId);
//       expect(transaction.description).toBe(data.description);
//       expect(transaction.createdAt).toBe(data.createdAt);
//       expect(transaction.updatedAt).toBe(data.updatedAt);
//       expect(transaction.isNew).toBe(false);
//       expect(transaction.entriesCount).toBe(0);
//     });

//     it('should restore transaction with entries', () => {
//       const data = {
//         createdAt: new Date('2023-01-01'),
//         description: 'Transaction with entries',
//         entries: [
//           {
//             createdAt: new Date('2023-01-01'),
//             description: 'Entry 1',
//             id: 'entry-1' as UUID,
//             transactionId: 'transaction-456' as UUID,
//             updatedAt: new Date('2023-01-01'),
//           },
//           {
//             createdAt: new Date('2023-01-01'),
//             description: 'Entry 2',
//             id: 'entry-2' as UUID,
//             transactionId: 'transaction-456' as UUID,
//             updatedAt: new Date('2023-01-01'),
//           },
//         ],
//         id: 'transaction-456' as UUID,
//         updatedAt: new Date('2023-01-02'),
//         userId,
//       };

//       const transaction = Transaction.restore(data);

//       expect(transaction.entriesCount).toBe(2);
//       expect(transaction.entries[0].description).toBe('Entry 1');
//       expect(transaction.entries[1].description).toBe('Entry 2');
//     });

//     it('should trim description when restoring', () => {
//       const data = {
//         createdAt: new Date('2023-01-01'),
//         description: '  Restored transaction  ',
//         id: 'transaction-456' as UUID,
//         updatedAt: new Date('2023-01-02'),
//         userId,
//       };

//       const transaction = Transaction.restore(data);

//       expect(transaction.description).toBe('Restored transaction');
//     });

//     it('should throw error for missing ID', () => {
//       expect(() =>
//         Transaction.restore({
//           createdAt: new Date(),
//           description: 'Test',
//           id: null,
//           updatedAt: new Date(),
//           userId,
//         }),
//       ).toThrow('ID is required for existing transaction');
//     });

//     it('should throw error for missing user ID', () => {
//       expect(() =>
//         Transaction.restore({
//           createdAt: new Date(),
//           description: 'Test',
//           id: 'transaction-456' as UUID,
//           updatedAt: new Date(),
//           userId: '' as UUID,
//         }),
//       ).toThrow('User ID is required');
//     });

//     it('should throw error for missing creation date', () => {
//       const invalidData = {
//         description: 'Test',
//         id: 'transaction-456' as UUID,
//         updatedAt: new Date(),
//         userId,
//       };

//       expect(() =>
//         // eslint-disable-next-line @typescript-eslint/no-explicit-any
//         Transaction.restore(invalidData as any),
//       ).toThrow('Creation date is required for existing transaction');
//     });

//     it('should throw error for missing update date', () => {
//       const invalidData = {
//         createdAt: new Date(),
//         description: 'Test',
//         id: 'transaction-456' as UUID,
//         userId,
//       };

//       expect(() =>
//         // eslint-disable-next-line @typescript-eslint/no-explicit-any
//         Transaction.restore(invalidData as any),
//       ).toThrow('Update date is required for existing transaction');
//     });

//     it('should throw error for empty description', () => {
//       expect(() =>
//         Transaction.restore({
//           createdAt: new Date(),
//           description: '',
//           id: 'transaction-456' as UUID,
//           updatedAt: new Date(),
//           userId,
//         }),
//       ).toThrow('Description is required');
//     });
//   });

//   describe('updateDescription', () => {
//     it('should update description', () => {
//       const transaction = Transaction.create({
//         description: 'Old description',
//         userId,
//       });

//       const newDescription = 'New description';
//       transaction.updateDescription(newDescription);

//       expect(transaction.description).toBe(newDescription);
//     });

//     it('should trim description', () => {
//       const transaction = Transaction.create({ description: 'Test', userId });

//       transaction.updateDescription('  New description  ');

//       expect(transaction.description).toBe('New description');
//     });

//     it('should update updatedAt timestamp', () => {
//       const transaction = Transaction.create({ description: 'Test', userId });
//       const initialUpdatedAt = transaction.updatedAt;

//       // Небольшая задержка для гарантии изменения времени
//       setTimeout(() => {
//         transaction.updateDescription('Updated');

//         expect(transaction.updatedAt.getTime()).toBeGreaterThan(
//           initialUpdatedAt.getTime(),
//         );
//       }, 1);
//     });

//     it('should throw error for empty description', () => {
//       const transaction = Transaction.create({ description: 'Test', userId });

//       expect(() => transaction.updateDescription('')).toThrow(
//         'Description cannot be empty',
//       );
//       expect(() => transaction.updateDescription('   ')).toThrow(
//         'Description cannot be empty',
//       );
//     });

//     it('should throw error for description too long', () => {
//       const transaction = Transaction.create({ description: 'Test', userId });
//       const longDescription = 'a'.repeat(501);

//       expect(() => transaction.updateDescription(longDescription)).toThrow(
//         'Description cannot exceed 500 characters',
//       );
//     });

//     it('should allow exactly 500 characters', () => {
//       const transaction = Transaction.create({ description: 'Test', userId });
//       const maxDescription = 'a'.repeat(500);

//       transaction.updateDescription(maxDescription);

//       expect(transaction.description).toBe(maxDescription);
//     });
//   });

//   describe('entry management', () => {
//     it('should add entry to saved transaction', () => {
//       const transaction = Transaction.create({
//         description: 'Test transaction',
//         userId,
//       }).withId('transaction-123' as UUID);

//       const entry = transaction.addEntry({ description: 'Test entry' });

//       expect(transaction.entriesCount).toBe(1);
//       expect(entry.description).toBe('Test entry');
//       expect(entry.transactionId).toBe('transaction-123');
//     });

//     it('should throw error when adding entry to unsaved transaction', () => {
//       const transaction = Transaction.create({
//         description: 'Test transaction',
//         userId,
//       });

//       expect(() => transaction.addEntry({ description: 'Test entry' })).toThrow(
//         'Cannot add entries to unsaved transaction',
//       );
//     });

//     it('should remove entry by ID', () => {
//       const transaction = Transaction.restore({
//         createdAt: new Date(),
//         description: 'Test transaction',
//         entries: [
//           {
//             createdAt: new Date(),
//             description: 'Entry 1',
//             id: 'entry-1' as UUID,
//             transactionId: 'transaction-123' as UUID,
//             updatedAt: new Date(),
//           },
//           {
//             createdAt: new Date(),
//             description: 'Entry 2',
//             id: 'entry-2' as UUID,
//             transactionId: 'transaction-123' as UUID,
//             updatedAt: new Date(),
//           },
//         ],
//         id: 'transaction-123' as UUID,
//         updatedAt: new Date(),
//         userId,
//       });

//       const removed = transaction.removeEntry('entry-1' as UUID);

//       expect(removed).toBe(true);
//       expect(transaction.entriesCount).toBe(1);
//       expect(transaction.entries[0].id).toBe('entry-2');
//     });

//     it('should return false when removing non-existent entry', () => {
//       const transaction = Transaction.create({
//         description: 'Test transaction',
//         userId,
//       });

//       const removed = transaction.removeEntry('non-existent' as UUID);

//       expect(removed).toBe(false);
//     });

//     it('should get entry by ID', () => {
//       const transaction = Transaction.restore({
//         createdAt: new Date(),
//         description: 'Test transaction',
//         entries: [
//           {
//             createdAt: new Date(),
//             description: 'Entry 1',
//             id: 'entry-1' as UUID,
//             transactionId: 'transaction-123' as UUID,
//             updatedAt: new Date(),
//           },
//         ],
//         id: 'transaction-123' as UUID,
//         updatedAt: new Date(),
//         userId,
//       });

//       const entry = transaction.getEntry('entry-1' as UUID);

//       expect(entry).toBeDefined();
//       expect(entry!.id).toBe('entry-1');
//       expect(entry!.description).toBe('Entry 1');
//     });

//     it('should return undefined for non-existent entry', () => {
//       const transaction = Transaction.create({
//         description: 'Test transaction',
//         userId,
//       });

//       const entry = transaction.getEntry('non-existent' as UUID);

//       expect(entry).toBeUndefined();
//     });

//     it('should clear all entries', () => {
//       const transaction = Transaction.restore({
//         createdAt: new Date(),
//         description: 'Test transaction',
//         entries: [
//           {
//             createdAt: new Date(),
//             description: 'Entry 1',
//             id: 'entry-1' as UUID,
//             transactionId: 'transaction-123' as UUID,
//             updatedAt: new Date(),
//           },
//           {
//             createdAt: new Date(),
//             description: 'Entry 2',
//             id: 'entry-2' as UUID,
//             transactionId: 'transaction-123' as UUID,
//             updatedAt: new Date(),
//           },
//         ],
//         id: 'transaction-123' as UUID,
//         updatedAt: new Date(),
//         userId,
//       });

//       expect(transaction.entriesCount).toBe(2);

//       transaction.clearEntries();

//       expect(transaction.entriesCount).toBe(0);
//       expect(transaction.entries).toEqual([]);
//     });

//     it('should not update timestamp when clearing empty entries', () => {
//       const transaction = Transaction.create({
//         description: 'Test transaction',
//         userId,
//       });
//       const initialUpdatedAt = transaction.updatedAt;

//       transaction.clearEntries();

//       expect(transaction.updatedAt).toBe(initialUpdatedAt);
//     });
//   });

//   describe('business rules validation', () => {
//     it('should validate empty transaction as invalid', () => {
//       const transaction = Transaction.create({
//         description: 'Test transaction',
//         userId,
//       });

//       const validation = transaction.validateBusinessRules();

//       expect(validation.isValid).toBe(false);
//       expect(validation.errors).toContain(
//         'Transaction must have at least one entry',
//       );
//     });

//     it('should validate transaction with entries as valid', () => {
//       const transaction = Transaction.restore({
//         createdAt: new Date(),
//         description: 'Test transaction',
//         entries: [
//           {
//             createdAt: new Date(),
//             description: 'Entry 1',
//             id: 'entry-1' as UUID,
//             transactionId: 'transaction-123' as UUID,
//             updatedAt: new Date(),
//           },
//         ],
//         id: 'transaction-123' as UUID,
//         updatedAt: new Date(),
//         userId,
//       });

//       const validation = transaction.validateBusinessRules();

//       expect(validation.isValid).toBe(true);
//       expect(validation.errors).toEqual([]);
//     });

//     it('should validate entries without descriptions as invalid', () => {
//       const transaction = Transaction.restore({
//         createdAt: new Date(),
//         description: 'Test transaction',
//         entries: [
//           {
//             createdAt: new Date(),
//             description: 'Entry 1',
//             id: 'entry-1' as UUID,
//             transactionId: 'transaction-123' as UUID,
//             updatedAt: new Date(),
//           },
//           {
//             createdAt: new Date(),
//             description: '',
//             id: 'entry-2' as UUID,
//             transactionId: 'transaction-123' as UUID,
//             updatedAt: new Date(),
//           },
//         ],
//         id: 'transaction-123' as UUID,
//         updatedAt: new Date(),
//         userId,
//       });

//       const validation = transaction.validateBusinessRules();

//       expect(validation.isValid).toBe(false);
//       expect(validation.errors).toContain('All entries must have descriptions');
//     });
//   });

//   describe('withId', () => {
//     it('should create transaction with ID', () => {
//       const transaction = Transaction.create({
//         description: 'Test transaction',
//         userId,
//       });

//       const newId = 'new-transaction-id' as UUID;
//       const transactionWithId = transaction.withId(newId);

//       expect(transactionWithId.id).toBe(newId);
//       expect(transactionWithId.userId).toBe(userId);
//       expect(transactionWithId.description).toBe('Test transaction');
//     });

//     it('should throw error when adding ID to transaction that has ID', () => {
//       const transaction = Transaction.restore({
//         createdAt: new Date(),
//         description: 'Test',
//         id: 'existing-id' as UUID,
//         updatedAt: new Date(),
//         userId,
//       });

//       expect(() => transaction.withId('new-id' as UUID)).toThrow(
//         'Transaction already has an ID',
//       );
//     });
//   });

//   describe('toData', () => {
//     it('should serialize new transaction to data', () => {
//       const transaction = Transaction.create({
//         description: 'Test transaction',
//         userId,
//       });
//       const data = transaction.toData();

//       expect(data.id).toBeNull();
//       expect(data.userId).toBe(userId);
//       expect(data.description).toBe('Test transaction');
//       expect(data.createdAt).toBeInstanceOf(Date);
//       expect(data.updatedAt).toBeInstanceOf(Date);
//       expect(data.entries).toEqual([]);
//     });

//     it('should serialize existing transaction with entries to data', () => {
//       const originalData = {
//         createdAt: new Date('2023-01-01'),
//         description: 'Test transaction',
//         entries: [
//           {
//             createdAt: new Date('2023-01-01'),
//             description: 'Entry 1',
//             id: 'entry-1' as UUID,
//             transactionId: 'transaction-123' as UUID,
//             updatedAt: new Date('2023-01-01'),
//           },
//         ],
//         id: 'transaction-123' as UUID,
//         updatedAt: new Date('2023-01-02'),
//         userId,
//       };

//       const transaction = Transaction.restore(originalData);
//       const data = transaction.toData();

//       expect(data).toEqual(originalData);
//     });
//   });

//   describe('equals', () => {
//     it('should return true for transactions with same ID', () => {
//       const id = 'transaction-123' as UUID;
//       const transaction1 = Transaction.restore({
//         createdAt: new Date(),
//         description: 'Transaction 1',
//         id,
//         updatedAt: new Date(),
//         userId,
//       });
//       const transaction2 = Transaction.restore({
//         createdAt: new Date(),
//         description: 'Transaction 2',
//         id,
//         updatedAt: new Date(),
//         userId: 'other-user' as UUID,
//       });

//       expect(transaction1.equals(transaction2)).toBe(true);
//     });

//     it('should return false for transactions with different IDs', () => {
//       const transaction1 = Transaction.restore({
//         createdAt: new Date(),
//         description: 'Transaction 1',
//         id: 'transaction-1' as UUID,
//         updatedAt: new Date(),
//         userId,
//       });
//       const transaction2 = Transaction.restore({
//         createdAt: new Date(),
//         description: 'Transaction 2',
//         id: 'transaction-2' as UUID,
//         updatedAt: new Date(),
//         userId,
//       });

//       expect(transaction1.equals(transaction2)).toBe(false);
//     });

//     it('should compare by content for new transactions', () => {
//       const transaction1 = Transaction.create({
//         description: 'Same description',
//         userId,
//       });
//       const transaction2 = Transaction.create({
//         description: 'Same description',
//         userId,
//       });
//       const transaction3 = Transaction.create({
//         description: 'Different description',
//         userId,
//       });

//       expect(transaction1.equals(transaction2)).toBe(true);
//       expect(transaction1.equals(transaction3)).toBe(false);
//     });

//     it('should return false for new transaction vs existing transaction', () => {
//       const newTransaction = Transaction.create({
//         description: 'Test',
//         userId,
//       });
//       const existingTransaction = Transaction.restore({
//         createdAt: new Date(),
//         description: 'Test',
//         id: 'transaction-123' as UUID,
//         updatedAt: new Date(),
//         userId,
//       });

//       expect(newTransaction.equals(existingTransaction)).toBe(false);
//     });
//   });

//   describe('business logic', () => {
//     it('should have correct isNew property for new transaction', () => {
//       const transaction = Transaction.create({ description: 'Test', userId });

//       expect(transaction.isNew).toBe(true);
//     });

//     it('should have correct isNew property for existing transaction', () => {
//       const transaction = Transaction.restore({
//         createdAt: new Date(),
//         description: 'Test',
//         id: 'transaction-123' as UUID,
//         updatedAt: new Date(),
//         userId,
//       });

//       expect(transaction.isNew).toBe(false);
//     });

//     it('should always allow modifications', () => {
//       const newTransaction = Transaction.create({
//         description: 'Test',
//         userId,
//       });
//       const existingTransaction = Transaction.restore({
//         createdAt: new Date(),
//         description: 'Test',
//         id: 'transaction-123' as UUID,
//         updatedAt: new Date(),
//         userId,
//       });

//       expect(newTransaction.canBeModified).toBe(true);
//       expect(existingTransaction.canBeModified).toBe(true);
//     });

//     it('should return readonly entries array', () => {
//       const transaction = Transaction.create({
//         description: 'Test',
//         userId,
//       });

//       const entries = transaction.entries;
//       expect(Array.isArray(entries)).toBe(true);

//       // Проверяем, что это новый массив (не ссылка)
//       expect(entries).not.toBe(transaction.entries);
//     });
//   });
// });
